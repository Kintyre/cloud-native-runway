#1:  Introduction & Background
==============================

Kintyre as a technical services delivery firm has real-life experience providing solutions to clients across very diverse business domains, technical stacks, driven by many different needs and budgets.  Said another way we benefit from higher frequency business and technical exposure than many IT shops working in a more traditional setting.  In addition to that we often start projects from scratch and work them through delivery which gives us the benefit of researching new technologies against requirements and working them into our projects on a much higher frequency than would be practical in most other business models other than consulting.  Working this way over time we collectively have built up a pretty good tribal knowledge about what modern application development really looks like in practice,  what works,  what doesn't and what works but doesn't feel quite right.  We started asking ourselves how to best condense our collective experience into something more tangible, referenceable, shareable (pick your adjective) so we built a reference app.  In addition to being something of well... a referenced app,  we have a polished foundation/artifact that we can use to get a new client project off the ground very, very quickly with all of the foundational stuff worked out; no bugs, no “how did I do that again”,  it's there.   This project is also not static,  as we learn new things or begin leveraging new technologies we are diligent to bake it back into the reference app using everything we have learned as a best practice.  This blog series walks through this process attempting to share what we have learned along the way so that you can see the whole picture.

So what do we have and why?
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The application itself is a cloud-native application, although I am hearing the term cloud-only more recently as the way to phrase this.  We have tried very hard to make technical choices that make the application as cloud provider agnostic as possible even though most of the application work we do at this point is AWS.  

Some reasons for this are:

* At a CTO level there exists a multitude of concerns that lead to hybrid cloud strategies because of things like security,  long term cloud provider viability,  compliance,  etc… 
* The cloud provider landscape is constantly changing and evolving.
* Our clients’ cloud provider preferences are ever-changing.
* Suffice it to say one of the foundational design principals we use for the project is for it to be as cloud provider agnostic as possible but admittedly this is probably impossible to achieve right now.

Technical Stack
^^^^^^^^^^^^^^^

Serverless Framework:  We have chosen to use the Serverless Framework for configuration and deployment considerations instead of a more native solution like say CloudFormation.  This decision gives us cloud provider flexibility due to its ability to target the major relevant cloud providers and it is also very well supported and is evolving with the industry.

**CodeShip**:  We have chosen CodeShip as a CICD platform as opposed to a more platform native solution like AWS CodeDeploy because again it decouples us from any given cloud provider and gives us flexibility.  The other reason for the choice is that it is very simple to get a basic pipeline up and running but it has the sophistication to grow as our demands for it does.

**JavaScript/NodeJS**:  Organizationally we use and have experience across many different programming languages but for the purpose of cloud-native development we have centered on JavaScript/NodeJS because it is common across the UI layer and the backend of the application,  is generally well supported across browsers,  cloud providers and has mature tooling and library support.

**Auth0**:  For authentication and user management we have chosen to use Auth0 instead of a more native offering like AWS Cognito.  That choice was motivated by the same portability considerations driving the other component level selections we have made.  Auth0 is a SaaS solution with a nice UI that offers the flexibility to integrate with pretty much anything we come across in terms of needs.

**AWS**:  Although one of the driving architectural goals for the application is to be as cloud provider agnostic as possible,  as I mentioned earlier, most of what we do at this point is centered around the AWS cloud ecosystem.  We see much more demand for custom application development on AWS and see it as best of breed from a cloud provider perspective and as such have chosen it for most of our attention.  Having said that,  that story is one that is constantly evolving and providers like Azure become more and more compelling all of the time,  hence the cloud-agnostic approach to the architecture.

**OpenTrace / SignalFX**:   Later in this blog series, I will be getting into the weeds of the reference application in detail but it is implemented using a microservices API which presents many architectural advantages over past design patterns but figuring out what service depends on what other service and what is breaking along the way in NOT one of those advantages.  In fact this gets quite challenging when microservice applications start getting some size to them.  This aspect of our reference app is very much still maturing but is heading in the direction of OpenTrace and SignalFX for service dependency visualization, general support, and issue traceability.

What's Next?
^^^^^^^^^^^^

This first blog post in this series is setting up a big picture understanding of what considerations went into creating the reference application in the first place and some of the high-level technical considerations that were made.  In the next post I will be starting to get into the weeds of setting up the hosting environment.
